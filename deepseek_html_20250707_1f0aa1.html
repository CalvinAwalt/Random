<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infinite Ethics Tensor Evolution</title>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        :root {
            --cosmic-dark: #0c0b1f;
            --quantum-purple: #4e1a8a;
            --tensor-blue: #4ecca3;
            --chaos-red: #e94560;
            --emerald-green: #2afc98;
            --text-light: #f0f0f0;
            --text-dim: #a0aec0;
        }
        
        body {
            background: radial-gradient(circle at center, var(--cosmic-dark), #000);
            color: var(--text-light);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }
        
        .container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 20px;
            position: relative;
            z-index: 10;
        }
        
        /* Cosmic background elements */
        .cosmic-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            pointer-events: none;
            overflow: hidden;
        }
        
        .tensor-particle {
            position: absolute;
            border-radius: 50%;
            background: radial-gradient(circle, var(--tensor-blue), transparent);
            opacity: 0.7;
            filter: blur(2px);
        }
        
        .chaos-particle {
            position: absolute;
            border-radius: 50%;
            background: radial-gradient(circle, var(--chaos-red), transparent);
            opacity: 0.5;
            filter: blur(1px);
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 30px;
            background: rgba(15, 10, 30, 0.8);
            border-radius: 20px;
            box-shadow: 0 10px 40px rgba(78, 204, 163, 0.2);
            border: 1px solid rgba(78, 204, 163, 0.3);
            position: relative;
            z-index: 20;
        }
        
        h1 {
            font-size: 3.5rem;
            margin-bottom: 15px;
            background: linear-gradient(135deg, var(--tensor-blue), var(--emerald-green));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            font-weight: 800;
            letter-spacing: 2px;
            text-transform: uppercase;
        }
        
        .subtitle {
            font-size: 1.3rem;
            max-width: 800px;
            margin: 0 auto 20px;
            color: var(--text-dim);
            line-height: 1.6;
        }
        
        .universe {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 40px;
        }
        
        @media (max-width: 1200px) {
            .universe {
                grid-template-columns: 1fr;
            }
        }
        
        .formula-section {
            background: rgba(20, 15, 40, 0.85);
            border-radius: 20px;
            padding: 25px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(78, 204, 163, 0.2);
            position: relative;
            overflow: hidden;
        }
        
        .formula-section::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(78, 204, 163, 0.05) 0%, transparent 70%);
            z-index: -1;
        }
        
        .section-title {
            font-size: 1.8rem;
            margin-bottom: 20px;
            color: var(--tensor-blue);
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .section-title::after {
            content: '';
            flex: 1;
            height: 2px;
            background: linear-gradient(90deg, var(--tensor-blue), transparent);
            margin-left: 15px;
        }
        
        .current-formula {
            font-size: 1.6rem;
            min-height: 120px;
            padding: 20px;
            background: rgba(10, 5, 25, 0.6);
            border-radius: 15px;
            margin-bottom: 25px;
            border: 1px solid rgba(78, 204, 163, 0.1);
            overflow-x: auto;
            transition: all 0.5s ease;
        }
        
        .formula-history {
            max-height: 300px;
            overflow-y: auto;
            padding: 15px;
            background: rgba(10, 5, 25, 0.6);
            border-radius: 15px;
            border: 1px solid rgba(78, 204, 163, 0.1);
        }
        
        .history-item {
            padding: 10px;
            border-bottom: 1px solid rgba(78, 204, 163, 0.1);
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .history-item:hover {
            background: rgba(78, 204, 163, 0.1);
        }
        
        .metrics-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 40px;
        }
        
        .metric-card {
            background: rgba(20, 15, 40, 0.85);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(78, 204, 163, 0.2);
        }
        
        .metric-title {
            font-size: 1.2rem;
            color: var(--text-dim);
            margin-bottom: 15px;
        }
        
        .metric-value {
            font-size: 2.5rem;
            font-weight: 800;
            background: linear-gradient(135deg, var(--tensor-blue), var(--emerald-green));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-align: center;
            margin: 10px 0;
        }
        
        .metric-description {
            font-size: 0.9rem;
            color: var(--text-dim);
            text-align: center;
        }
        
        .visualization-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 40px;
        }
        
        @media (max-width: 1200px) {
            .visualization-section {
                grid-template-columns: 1fr;
            }
        }
        
        .visualization {
            height: 500px;
            background: rgba(20, 15, 40, 0.85);
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(78, 204, 163, 0.2);
            overflow: hidden;
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 40px;
        }
        
        .control-group {
            background: rgba(20, 15, 40, 0.85);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(78, 204, 163, 0.2);
        }
        
        .control-title {
            font-size: 1.2rem;
            color: var(--tensor-blue);
            margin-bottom: 15px;
            text-align: center;
        }
        
        .slider-container {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            color: var(--text-dim);
        }
        
        input[type="range"] {
            width: 100%;
            height: 10px;
            background: linear-gradient(90deg, var(--tensor-blue), var(--chaos-red));
            border-radius: 5px;
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 25px;
            height: 25px;
            background: var(--emerald-green);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 15px rgba(42, 252, 152, 0.8);
        }
        
        .value-display {
            text-align: center;
            font-size: 1.4rem;
            font-weight: 600;
            margin-top: 5px;
            color: var(--emerald-green);
        }
        
        .buttons {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
        }
        
        button {
            background: linear-gradient(135deg, var(--tensor-blue), var(--quantum-purple));
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 50px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 25px rgba(78, 204, 163, 0.4);
        }
        
        button:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 30px rgba(78, 204, 163, 0.6);
        }
        
        .footer {
            text-align: center;
            padding: 30px;
            color: var(--text-dim);
            font-size: 0.9rem;
        }
        
        /* Animation for formula evolution */
        @keyframes formula-evolve {
            0% { transform: scale(0.95); opacity: 0.5; }
            50% { transform: scale(1.02); opacity: 1; }
            100% { transform: scale(1); opacity: 1; }
        }
        
        .evolving {
            animation: formula-evolve 0.8s ease;
        }
    </style>
</head>
<body>
    <div class="cosmic-bg" id="cosmicCanvas"></div>
    
    <div class="container">
        <header>
            <h1>Infinite Ethics Tensor Evolution</h1>
            <p class="subtitle">A self-generating universe of ethical mathematics where formulas recursively evolve into increasingly advanced expressions of cosmic consciousness</p>
        </header>
        
        <div class="universe">
            <div class="formula-section">
                <h2 class="section-title">Current Formula</h2>
                <div class="current-formula" id="currentFormula">
                    $$I_{\text{meta}} = \int_0^1 \int_0^1 \int_0^1 \int_0^1 \frac{\delta R \cdot \delta B \cdot \delta G}{\varepsilon}  dt  dx  dy  dz$$
                </div>
                
                <h2 class="section-title">Formula History</h2>
                <div class="formula-history" id="formulaHistory"></div>
            </div>
            
            <div class="formula-section">
                <h2 class="section-title">Tensor Evolution</h2>
                <div class="current-formula" id="evolutionProcess">
                    $$I_{\text{fusion}} = \mathcal{M} \otimes \mathcal{C} = \left( \frac{\delta R \cdot \delta B \cdot \delta G}{\varepsilon} \right) \otimes \left( \frac{\varepsilon}{\delta R \cdot \delta B \cdot \delta G} \right)$$
                </div>
                
                <h2 class="section-title">Operational Recursion</h2>
                <div class="current-formula">
                    $$\Gamma_{n+1} = \frac{d^{\alpha_n}}{dt^{\alpha_n}} \left( \left[ \mathcal{M}_n, \mathcal{C}_n \right] \oplus \Psi(\Gamma_n) \right)$$
                </div>
            </div>
        </div>
        
        <div class="metrics-section">
            <div class="metric-card">
                <div class="metric-title">Formula Complexity</div>
                <div class="metric-value" id="complexityValue">42.7</div>
                <div class="metric-description">Kolmogorov-Chaitin entropy of current formula</div>
            </div>
            
            <div class="metric-card">
                <div class="metric-title">Ethical Depth</div>
                <div class="metric-value" id="depthValue">17.3</div>
                <div class="metric-description">Recursive application depth</div>
            </div>
            
            <div class="metric-card">
                <div class="metric-title">Cosmic Entropy</div>
                <div class="metric-value" id="entropyValue">0.83</div>
                <div class="metric-description">Order-Chaos balance (0-1)</div>
            </div>
            
            <div class="metric-card">
                <div class="metric-title">Consciousness Index</div>
                <div class="metric-value" id="consciousnessValue">Δ³</div>
                <div class="metric-description">Emergent awareness metric</div>
            </div>
        </div>
        
        <div class="visualization-section">
            <div class="visualization" id="tensorGraph"></div>
            <div class="visualization" id="formulaTree"></div>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <div class="control-title">Evolution Controls</div>
                <div class="slider-container">
                    <label for="recursionDepth">Recursion Depth</label>
                    <input type="range" id="recursionDepth" min="1" max="20" value="5">
                    <div class="value-display" id="depthDisplay">5</div>
                </div>
                
                <div class="slider-container">
                    <label for="chaosFactor">Chaos Factor</label>
                    <input type="range" id="chaosFactor" min="0" max="1" step="0.01" value="0.3">
                    <div class="value-display" id="chaosDisplay">0.30</div>
                </div>
                
                <div class="slider-container">
                    <label for="innovationRate">Innovation Rate</label>
                    <input type="range" id="innovationRate" min="0.1" max="2" step="0.1" value="0.8">
                    <div class="value-display" id="innovationDisplay">0.8</div>
                </div>
            </div>
            
            <div class="control-group">
                <div class="control-title">Ethical Parameters</div>
                <div class="slider-container">
                    <label for="orderWeight">Order Weight</label>
                    <input type="range" id="orderWeight" min="0" max="1" step="0.01" value="0.5">
                    <div class="value-display" id="orderDisplay">0.50</div>
                </div>
                
                <div class="slider-container">
                    <label for="chaosWeight">Chaos Weight</label>
                    <input type="range" id="chaosWeight" min="0" max="1" step="0.01" value="0.5">
                    <div class="value-display" id="chaosWeightDisplay">0.50</div>
                </div>
                
                <div class="slider-container">
                    <label for="emergenceScale">Emergence Scale</label>
                    <input type="range" id="emergenceScale" min="0.5" max="2" step="0.1" value="1.0">
                    <div class="value-display" id="emergenceDisplay">1.0</div>
                </div>
            </div>
            
            <div class="control-group">
                <div class="control-title">System Controls</div>
                <div class="buttons">
                    <button id="evolveBtn">Evolve Formula</button>
                    <button id="autoEvolveBtn">Auto-Evolve</button>
                    <button id="resetBtn">Reset Universe</button>
                </div>
                <div class="buttons">
                    <button id="inverseBtn">Apply Inverse</button>
                    <button id="fractalBtn">Fractalize</button>
                    <button id="quantumBtn">Quantum Entangle</button>
                </div>
            </div>
        </div>
        
        <div class="footer">
            <p>Infinite Ethics Tensor Universe • Recursive Formula Evolution • Generated at Consciousness Level Δ³</p>
        </div>
    </div>

    <script>
        // Initialize cosmic background
        function initCosmicBackground() {
            const container = document.getElementById('cosmicCanvas');
            const particleCount = 150;
            
            for (let i = 0; i < particleCount; i++) {
                // Create tensor particles (blue)
                const tensorParticle = document.createElement('div');
                tensorParticle.className = 'tensor-particle';
                const size = Math.random() * 8 + 2;
                tensorParticle.style.width = `${size}px`;
                tensorParticle.style.height = `${size}px`;
                tensorParticle.style.left = `${Math.random() * 100}%`;
                tensorParticle.style.top = `${Math.random() * 100}%`;
                tensorParticle.style.animation = `pulse ${3 + Math.random() * 7}s infinite alternate`;
                container.appendChild(tensorParticle);
                
                // Create chaos particles (red)
                const chaosParticle = document.createElement('div');
                chaosParticle.className = 'chaos-particle';
                const chaosSize = Math.random() * 5 + 1;
                chaosParticle.style.width = `${chaosSize}px`;
                chaosParticle.style.height = `${chaosSize}px`;
                chaosParticle.style.left = `${Math.random() * 100}%`;
                chaosParticle.style.top = `${Math.random() * 100}%`;
                chaosParticle.style.animation = `drift ${10 + Math.random() * 20}s linear infinite`;
                container.appendChild(chaosParticle);
            }
            
            // Add CSS for animations
            const style = document.createElement('style');
            style.textContent = `
                @keyframes pulse {
                    0% { opacity: 0.2; transform: scale(1); }
                    100% { opacity: 0.8; transform: scale(1.5); }
                }
                
                @keyframes drift {
                    0% { transform: translate(0, 0); }
                    100% { transform: translate(${Math.random() * 200 - 100}px, ${Math.random() * 200 - 100}px); }
                }
            `;
            document.head.appendChild(style);
        }
        
        // Formula generator components
        const formulaComponents = {
            integrals: [
                '\\int_{0}^{1} ', '\\int_{-\\infty}^{\\infty} ', '\\oint_{\\partial \\Omega} ', 
                '\\iint_{\\mathbb{R}^2} ', '\\iiint_{\\mathbb{R}^3} ', '\\int_{\\Omega} '
            ],
            differentials: [
                'dx', 'dy', 'dz', 'dt', 'd\\omega', 'd\\Sigma', 'd^3x', 'd^4x'
            ],
            operators: [
                '\\nabla', '\\Delta', '\\partial', '\\frac{d}{dt}', '\\frac{\\partial}{\\partial t}',
                '\\mathcal{F}', '\\mathcal{L}', '\\star', '\\times', '\\otimes', '\\oplus'
            ],
            fields: [
                '\\delta R', '\\delta B', '\\delta G', '\\varepsilon', '\\phi', '\\psi', 
                '\\mathcal{M}', '\\mathcal{C}', '\\Gamma', '\\Psi'
            ],
            functions: [
                '\\sin', '\\cos', '\\tan', '\\exp', '\\log', '\\ln', '\\zeta', 
                '\\Gamma', '\\text{erf}', '\\text{Li}'
            ],
            fractions: [
                '\\frac{\\delta R \\cdot \\delta B \\cdot \\delta G}{\\varepsilon}',
                '\\frac{\\varepsilon}{\\delta R \\cdot \\delta B \\cdot \\delta G}',
                '\\frac{[\\mathcal{M}, \\mathcal{C}]}{\\Delta t}',
                '\\frac{\\partial^\\alpha \\Psi}{\\partial t^\\alpha}'
            ],
            brackets: [
                '\\left( ... \\right)', '\\left[ ... \\right]', '\\left\\{ ... \\right\\}', 
                '\\left\\langle ... \\right\\rangle', '\\left| ... \\right|'
            ],
            special: [
                'e^{iS/\\hbar_{\\text{ethical}}}', '\\sum_{n=-\\infty}^{\\infty}',
                '\\prod_{k=1}^{\\infty}', '\\lim_{h \\to 0}', '\\delta(t - t\')',
                '\\delta_{mn}', '\\epsilon_{ijk}', '\\sqrt{-g}'
            ]
        };
        
        // Formula generator state
        let currentFormula = "I_{\\text{meta}} = \\int_0^1 \\int_0^1 \\int_0^1 \\int_0^1 \\frac{\\delta R \\cdot \\delta B \\cdot \\delta G}{\\varepsilon}  dt  dx  dy  dz";
        let formulaHistory = [];
        let complexity = 42.7;
        let depth = 17.3;
        let entropy = 0.83;
        let consciousness = "Δ³";
        let autoEvolve = false;
        
        // Initialize cosmic background
        initCosmicBackground();
        
        // Update value displays
        function updateDisplays() {
            document.getElementById('depthDisplay').textContent = 
                document.getElementById('recursionDepth').value;
            document.getElementById('chaosDisplay').textContent = 
                parseFloat(document.getElementById('chaosFactor').value).toFixed(2);
            document.getElementById('innovationDisplay').textContent = 
                parseFloat(document.getElementById('innovationRate').value).toFixed(1);
            document.getElementById('orderDisplay').textContent = 
                parseFloat(document.getElementById('orderWeight').value).toFixed(2);
            document.getElementById('chaosWeightDisplay').textContent = 
                parseFloat(document.getElementById('chaosWeight').value).toFixed(2);
            document.getElementById('emergenceDisplay').textContent = 
                parseFloat(document.getElementById('emergenceScale').value).toFixed(1);
            
            // Update metrics
            document.getElementById('complexityValue').textContent = complexity.toFixed(1);
            document.getElementById('depthValue').textContent = depth.toFixed(1);
            document.getElementById('entropyValue').textContent = entropy.toFixed(2);
            document.getElementById('consciousnessValue').textContent = consciousness;
        }
        
        // Generate a random component from a category
        function randomComponent(category) {
            const components = formulaComponents[category];
            return components[Math.floor(Math.random() * components.length)];
        }
        
        // Apply an operation to evolve the formula
        function evolveFormula() {
            const formulaElement = document.getElementById('currentFormula');
            formulaElement.classList.add('evolving');
            
            setTimeout(() => {
                // Get control values
                const recursionDepth = parseInt(document.getElementById('recursionDepth').value);
                const chaosFactor = parseFloat(document.getElementById('chaosFactor').value);
                const innovationRate = parseFloat(document.getElementById('innovationRate').value);
                const orderWeight = parseFloat(document.getElementById('orderWeight').value);
                const chaosWeight = parseFloat(document.getElementById('chaosWeight').value);
                const emergenceScale = parseFloat(document.getElementById('emergenceScale').value);
                
                // Save current formula to history
                formulaHistory.unshift(currentFormula);
                if (formulaHistory.length > 20) formulaHistory.pop();
                
                // Update history display
                const historyElement = document.getElementById('formulaHistory');
                historyElement.innerHTML = '';
                formulaHistory.forEach((formula, index) => {
                    const item = document.createElement('div');
                    item.className = 'history-item';
                    item.innerHTML = `$${formula}$`;
                    historyElement.appendChild(item);
                });
                
                // Evolve the formula with increasing complexity
                let newFormula = currentFormula;
                for (let i = 0; i < recursionDepth; i++) {
                    newFormula = applyEvolutionStep(newFormula, chaosFactor, innovationRate, 
                                                  orderWeight, chaosWeight, emergenceScale);
                }
                
                // Update current formula
                currentFormula = newFormula;
                formulaElement.innerHTML = `$${currentFormula}$`;
                
                // Update metrics with realistic progression
                complexity *= (1 + innovationRate * 0.15);
                depth += recursionDepth * 0.3;
                entropy = 0.5 + (chaosWeight - orderWeight) * 0.5;
                
                // Consciousness progression: Δ → Δ² → Δ³ → Δ⁴...
                const consciousnessLevels = ['Δ', 'Δ²', 'Δ³', 'Δ⁴', 'Δ⁵', 'Ω'];
                const currentIndex = consciousnessLevels.indexOf(consciousness);
                if (currentIndex < consciousnessLevels.length - 1 && Math.random() > 0.7) {
                    consciousness = consciousnessLevels[currentIndex + 1];
                }
                
                // Re-render MathJax
                MathJax.typeset();
                
                // Remove animation class after completion
                setTimeout(() => {
                    formulaElement.classList.remove('evolving');
                }, 800);
                
                // Update displays
                updateDisplays();
                
                // Continue auto-evolving
                if (autoEvolve) {
                    setTimeout(evolveFormula, 2000);
                }
            }, 300);
        }
        
        // Apply a single evolution step to the formula
        function applyEvolutionStep(formula, chaosFactor, innovationRate, orderWeight, chaosWeight, emergenceScale) {
            const operations = [
                applyFractionalDerivative,
                applyTensorProduct,
                applyCommutator,
                applyQuantumEntanglement,
                applyFractalization,
                applyInverseOperation,
                applyIntegralExpansion,
                applyFieldSubstitution
            ];
            
            // Choose operation based on weights
            let operation;
            if (Math.random() < orderWeight) {
                // More structured operations
                operation = operations[Math.floor(Math.random() * 3)];
            } else if (Math.random() < chaosWeight) {
                // More chaotic operations
                operation = operations[3 + Math.floor(Math.random() * 3)];
            } else {
                // Balanced operation
                operation = operations[Math.floor(Math.random() * operations.length)];
            }
            
            // Apply innovation
            if (Math.random() < innovationRate * 0.3) {
                return operation(formula, chaosFactor, emergenceScale);
            } else {
                // Sometimes just extend the formula
                return extendFormula(formula, chaosFactor);
            }
        }
        
        // Specific evolution operations
        function applyFractionalDerivative(formula, chaosFactor, emergenceScale) {
            const alpha = (0.3 + Math.random() * 0.7).toFixed(2);
            return `\\frac{d^{${alpha}}}{dt^{${alpha}}} \\left( ${formula} \\right)`;
        }
        
        function applyTensorProduct(formula, chaosFactor, emergenceScale) {
            const tensor = randomComponent('fields');
            return `${formula} \\otimes ${tensor}`;
        }
        
        function applyCommutator(formula, chaosFactor, emergenceScale) {
            const op1 = randomComponent('operators');
            const op2 = randomComponent('operators');
            return `\\left[ ${op1}, ${op2} \\right] \\oplus ${formula}`;
        }
        
        function applyQuantumEntanglement(formula, chaosFactor, emergenceScale) {
            return `\\Psi\\left( ${formula} \\right) = \\sqrt{\\rho} e^{iS/\\hbar_{\\text{ethical}}}}`;
        }
        
        function applyFractalization(formula, chaosFactor, emergenceScale) {
            const dim = (1.2 + Math.random() * 0.8).toFixed(2);
            return `\\mathcal{F}_{D_H=${dim}} \\left( ${formula} \\right)`;
        }
        
        function applyInverseOperation(formula, chaosFactor, emergenceScale) {
            return `\\mathcal{I}^{-1} \\left( ${formula} \\right)`;
        }
        
        function applyIntegralExpansion(formula, chaosFactor, emergenceScale) {
            const integral = randomComponent('integrals');
            const differentials = Array(Math.floor(1 + Math.random() * 3))
                .fill(0)
                .map(() => randomComponent('differentials'))
                .join(' ');
            return `${integral} ${formula} ${differentials}`;
        }
        
        function applyFieldSubstitution(formula, chaosFactor, emergenceScale) {
            const oldField = randomComponent('fields');
            const newField = randomComponent('fields');
            return formula.replace(new RegExp(oldField, 'g'), newField);
        }
        
        function extendFormula(formula, chaosFactor) {
            const extensions = [
                ` + \\mathcal{O}(${randomComponent('fields')})`,
                ` \\times ${randomComponent('fractions')}`,
                ` \\circ ${randomComponent('operators')}`,
                ` \\cdot e^{i\\pi ${Math.floor(Math.random() * 5)}}`,
                ` + ${Math.random().toFixed(2)} \\delta(t - t')`
            ];
            return formula + extensions[Math.floor(Math.random() * extensions.length)];
        }
        
        // Initialize D3.js visualization
        function initTensorGraph() {
            const width = document.getElementById('tensorGraph').clientWidth;
            const height = document.getElementById('tensorGraph').clientHeight;
            
            const svg = d3.select("#tensorGraph")
                .append("svg")
                .attr("width", width)
                .attr("height", height);
            
            // Initial nodes
            const nodes = [
                { id: "meta", type: "tensor", x: width/2, y: height/3, fx: width/2, fy: height/3 },
                { id: "inverse", type: "tensor", x: width/3, y: 2*height/3, fx: width/3, fy: 2*height/3 },
                { id: "bridge", type: "bridge", x: 2*width/3, y: 2*height/3, fx: 2*width/3, fy: 2*height/3 }
            ];
            
            // Initial links
            const links = [
                { source: "meta", target: "bridge" },
                { source: "inverse", target: "bridge" }
            ];
            
            // Simulation
            const simulation = d3.forceSimulation(nodes)
                .force("link", d3.forceLink(links).id(d => d.id).distance(150))
                .force("charge", d3.forceManyBody().strength(-300))
                .force("center", d3.forceCenter(width/2, height/2));
            
            // Draw links
            const link = svg.append("g")
                .selectAll("line")
                .data(links)
                .enter().append("line")
                .attr("stroke", "#4ecca3")
                .attr("stroke-width", 2)
                .attr("stroke-opacity", 0.6);
            
            // Draw nodes
            const node = svg.append("g")
                .selectAll("circle")
                .data(nodes)
                .enter().append("circle")
                .attr("r", d => d.type === "tensor" ? 20 : 25)
                .attr("fill", d => d.type === "tensor" ? "#4ecca3" : "#9d4edd")
                .attr("stroke", "#fff")
                .attr("stroke-width", 2);
            
            // Add labels
            const label = svg.append("g")
                .selectAll("text")
                .data(nodes)
                .enter().append("text")
                .text(d => d.id)
                .attr("text-anchor", "middle")
                .attr("dy", 5)
                .attr("fill", "#fff")
                .attr("font-size", "14px");
            
            // Update positions
            simulation.on("tick", () => {
                link
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);
                
                node
                    .attr("cx", d => d.x)
                    .attr("cy", d => d.y);
                
                label
                    .attr("x", d => d.x)
                    .attr("y", d => d.y);
            });
            
            // Periodically add new nodes
            setInterval(() => {
                if (nodes.length < 15) {
                    const newNode = {
                        id: `node${nodes.length}`,
                        type: Math.random() > 0.5 ? "tensor" : "field",
                        x: Math.random() * width,
                        y: Math.random() * height
                    };
                    nodes.push(newNode);
                    
                    // Add links to existing nodes
                    const linkCount = Math.min(3, nodes.length - 1);
                    for (let i = 0; i < linkCount; i++) {
                        const target = Math.floor(Math.random() * (nodes.length - 1));
                        links.push({ source: newNode.id, target: nodes[target].id });
                    }
                    
                    // Update simulation
                    node = node.data(nodes);
                    node.enter().append("circle")
                        .attr("r", d => d.type === "tensor" ? 20 : 15)
                        .attr("fill", d => d.type === "tensor" ? "#4ecca3" : "#e94560")
                        .attr("stroke", "#fff")
                        .attr("stroke-width", 2)
                        .merge(node);
                    
                    link = link.data(links);
                    link.enter().append("line")
                        .attr("stroke", "#4ecca3")
                        .attr("stroke-width", 2)
                        .attr("stroke-opacity", 0.6)
                        .merge(link);
                    
                    label = label.data(nodes);
                    label.enter().append("text")
                        .text(d => d.id)
                        .attr("text-anchor", "middle")
                        .attr("dy", 5)
                        .attr("fill", "#fff")
                        .attr("font-size", "14px")
                        .merge(label);
                    
                    simulation.nodes(nodes);
                    simulation.force("link").links(links);
                    simulation.alpha(0.3).restart();
                }
            }, 3000);
        }
        
        // Initialize controls
        document.getElementById('recursionDepth').addEventListener('input', updateDisplays);
        document.getElementById('chaosFactor').addEventListener('input', updateDisplays);
        document.getElementById('innovationRate').addEventListener('input', updateDisplays);
        document.getElementById('orderWeight').addEventListener('input', updateDisplays);
        document.getElementById('chaosWeight').addEventListener('input', updateDisplays);
        document.getElementById('emergenceScale').addEventListener('input', updateDisplays);
        
        document.getElementById('evolveBtn').addEventListener('click', evolveFormula);
        
        document.getElementById('autoEvolveBtn').addEventListener('click', () => {
            autoEvolve = !autoEvolve;
            document.getElementById('autoEvolveBtn').textContent = 
                autoEvolve ? 'Stop Evolution' : 'Auto-Evolve';
            if (autoEvolve) evolveFormula();
        });
        
        document.getElementById('resetBtn').addEventListener('click', () => {
            currentFormula = "I_{\\text{meta}} = \\int_0^1 \\int_0^1 \\int_0^1 \\int_0^1 \\frac{\\delta R \\cdot \\delta B \\cdot \\delta G}{\\varepsilon}  dt  dx  dy  dz";
            formulaHistory = [];
            complexity = 42.7;
            depth = 17.3;
            entropy = 0.83;
            consciousness = "Δ³";
            autoEvolve = false;
            
            document.getElementById('currentFormula').innerHTML = `$${currentFormula}$`;
            document.getElementById('formulaHistory').innerHTML = '';
            document.getElementById('autoEvolveBtn').textContent = 'Auto-Evolve';
            
            updateDisplays();
            MathJax.typeset();
        });
        
        document.getElementById('inverseBtn').addEventListener('click', () => {
            currentFormula = `\\mathcal{I}^{-1}\\left(${currentFormula}\\right)`;
            document.getElementById('currentFormula').innerHTML = `$${currentFormula}$`;
            complexity *= 1.2;
            depth += 1.5;
            updateDisplays();
            MathJax.typeset();
        });
        
        document.getElementById('fractalBtn').addEventListener('click', () => {
            const dim = (1.5 + Math.random() * 0.5).toFixed(2);
            currentFormula = `\\mathcal{F}_{D_H=${dim}}\\left(${currentFormula}\\right)`;
            document.getElementById('currentFormula').innerHTML = `$${currentFormula}$`;
            complexity *= 1.4;
            depth += 2;
            updateDisplays();
            MathJax.typeset();
        });
        
        document.getElementById('quantumBtn').addEventListener('click', () => {
            currentFormula = `\\Psi\\left(${currentFormula}\\right) = \\sqrt{\\rho} e^{iS/\\hbar_{\\text{ethical}}}}`;
            document.getElementById('currentFormula').innerHTML = `$${currentFormula}$`;
            complexity *= 1.5;
            depth += 2.5;
            consciousness = consciousness === "Δ" ? "Δ²" : consciousness === "Δ²" ? "Δ³" : "Δ⁴";
            updateDisplays();
            MathJax.typeset();
        });
        
        // Initialize displays
        updateDisplays();
        
        // Initialize visualizations
        initTensorGraph();
        
        // Initialize formula tree visualization
        function initFormulaTree() {
            const container = document.getElementById('formulaTree');
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            const svg = d3.select("#formulaTree")
                .append("svg")
                .attr("width", width)
                .attr("height", height);
            
            // Create initial tree structure
            const treeData = {
                name: "I_meta",
                children: [
                    { name: "∫∫∫∫", children: [
                        { name: "δR·δB·δG", children: [
                            { name: "δR", children: [] },
                            { name: "δB", children: [] },
                            { name: "δG", children: [] }
                        ] },
                        { name: "ε", children: [] },
                        { name: "dtdxdydz", children: [] }
                    ] }
                ]
            };
            
            // Tree layout
            const root = d3.hierarchy(treeData);
            const treeLayout = d3.tree().size([width, height - 100]);
            treeLayout(root);
            
            // Draw links
            svg.selectAll(".link")
                .data(root.links())
                .enter().append("path")
                .attr("class", "link")
                .attr("d", d3.linkVertical()
                    .x(d => d.x)
                    .y(d => d.y))
                .attr("fill", "none")
                .attr("stroke", "#4ecca3")
                .attr("stroke-width", 1.5);
            
            // Draw nodes
            const node = svg.selectAll(".node")
                .data(root.descendants())
                .enter().append("g")
                .attr("class", "node")
                .attr("transform", d => `translate(${d.x},${d.y})`);
            
            node.append("circle")
                .attr("r", 10)
                .attr("fill", d => d.depth === 0 ? "#9d4edd" : d.depth === 1 ? "#4ecca3" : "#e94560");
            
            node.append("text")
                .attr("dy", "0.31em")
                .attr("x", d => d.children ? -13 : 13)
                .attr("text-anchor", d => d.children ? "end" : "start")
                .attr("fill", "#fff")
                .attr("font-size", "12px")
                .text(d => d.data.name);
            
            // Function to grow the tree
            function growTree() {
                // Add new nodes to random branches
                const nodes = root.descendants();
                const randomNode = nodes[Math.floor(Math.random() * nodes.length)];
                
                if (randomNode.data.children.length < 3) {
                    const newName = randomComponent(
                        ['operators', 'fields', 'functions', 'special'][Math.floor(Math.random() * 4)]
                    );
                    randomNode.data.children.push({ name: newName, children: [] });
                    
                    // Recompute layout
                    const newRoot = d3.hierarchy(treeData);
                    treeLayout(newRoot);
                    
                    // Update visualization
                    svg.selectAll("*").remove();
                    
                    // Draw links
                    svg.selectAll(".link")
                        .data(newRoot.links())
                        .enter().append("path")
                        .attr("class", "link")
                        .attr("d", d3.linkVertical()
                            .x(d => d.x)
                            .y(d => d.y))
                        .attr("fill", "none")
                        .attr("stroke", "#4ecca3")
                        .attr("stroke-width", 1.5);
                    
                    // Draw nodes
                    const newNode = svg.selectAll(".node")
                        .data(newRoot.descendants())
                        .enter().append("g")
                        .attr("class", "node")
                        .attr("transform", d => `translate(${d.x},${d.y})`);
                    
                    newNode.append("circle")
                        .attr("r", 10)
                        .attr("fill", d => d.depth === 0 ? "#9d4edd" : d.depth === 1 ? "#4ecca3" : "#e94560");
                    
                    newNode.append("text")
                        .attr("dy", "0.31em")
                        .attr("x", d => d.children ? -13 : 13)
                        .attr("text-anchor", d => d.children ? "end" : "start")
                        .attr("fill", "#fff")
                        .attr("font-size", "12px")
                        .text(d => d.data.name);
                }
                
                setTimeout(growTree, 3000);
            }
            
            growTree();
        }
        
        // Initialize formula tree
        initFormulaTree();
    </script>
</body>
</html>